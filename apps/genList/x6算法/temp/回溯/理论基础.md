本篇为 [代码随想录](https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB) 的笔记。在我看来，回溯就是使用递归层序遍历多叉树，而一个节点的子节点则是在生成后通过循环来遍历。

因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

回溯法解决的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，集合的大小构成了树的宽度 （集合的数目决定一层节点的数目），递归的深度构成的树的深度。递归就要有终止条件，所以必然是一棵高度有限的树（N 叉树）。
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

回溯算法模板框架如下：

```c++
void backtracking (参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    回溯将集合拆为多个子集（以及子集的子集，所以是树状）遍历
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}```


## 题目分类
组合问题：N 个数里面按一定规则找出 k 个数的集合，组合是无序的。
切割问题：一个字符串按一定规则有几种切割方式
子集问题：一个 N 个数的集合里有多少符合条件的子集
排列问题：N 个数按一定规则全排列，有几种排列方式
棋盘问题：N 皇后，解数独等等
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210219192050666.png)